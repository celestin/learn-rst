############
rst 基本语法
############

.. highlight:: text

Sphinx 默认使用 |reST| 标记语言(通常简称为 rst 或 reST), 要能够处理 Markdown 还需要额外的渲染器, 而且在了解一番过后, 发现 |reST| 支持的内容比 Markdown 更丰富, 于是决定学习一下. 建议克隆该库, 自己使用 ``make html`` 编译结果, 再对照源码学习 reStructureText 的语法.

|reST| 和 Python 一样, 很多表达都依赖缩进. (所以你的编辑器上最好有📏2333)

以下内容翻译自 `A ReStructuredText Primer <http://docutils.sourceforge.net/docs/user/rst/quickstart.html>`_:

:Author: Richard Jones
:Version: 5801
:Copyright: This document has been placed in the public domain.

结构
====

首先, 让我说 "结构化文本" 可能有些用词不当. |reST| 更像使用某些一致模式的 "轻松文本". 这些模式被 HTML 转换器解释产生 "非常结构化" 的文本, 该文本才可被 Web 浏览器使用.

最基本的被识别的模式是 `段落`. 这是一个被空行分隔的文本区块(一行就够了). 段落必须由相同的索引 -- 也就是说, 在它们的左边缘需要对齐. 开始缩进的段落将产生对应缩进的引用段落. 例如::

    这是一个段落. 它有点
    短.

        这个段落将会产生一个缩进块的文本, 通常用作表示引用其他文本.

    这是另一段.

结果:

这是一个段落. 它有点
短.

    这个段落将会产生一个缩进块的文本, 通常用作表示引用其他文本.

这是另一段.

文本样式
========

在段落和其他文本体内, 你可以使用额外的文本记号用 "\*斜体\*" 作 *斜体*
或者 "\*\*粗体\*\*" 作 **粗体**. 这被称作 "行内标记".

如果你想要一些显示为固定空间的纯文本, 使用 "\`\`双反引号\`\`". 注意
不要在双反引号里加任何别的标记 -- 例如星号 "\*".

如果你发现你想要使用单个独特的文本字符, 这通常也是可以的 -- |reST|
非常聪明. 例如, 单独的 * 星号被处理得很好, 像这个算式里的星号: 5*6=30.
如果你实际想要让 \*被星号包围的文本\* **不要** 被斜体化, 你需要表明
星号不是特殊的. 你通过放置反斜杠在它前面, 例如 "\\\*", 或者用闭合的
双反引号像这样::

    ``*``

.. tip::

    将内联标记想象成括号的一种形式, 并用相同的方式使用它: 在标记文本
    的前后. 由空格包围或单词中间的内联标记本身不会被识别, 有关详细信息, 参考标记规范.

标题
====

x 级标题分别对应 ``<hx>...</hx>``.

rst 中各级标题使用符号衬在文字下一行, 并且, 符号的数目应不少于文字数目. 对于中文等宽字符, 一个字符对应两个普通符号.

注意, rst 并不在意使用的符号类型, 只需要是 "相同符号衬托文字" 就会被解析为标题, 并根据符号的出现顺序与嵌套结构划分标题层级.

一般来讲, 会用以下符号来标注标题层级.

::

    一级标题
    ########

    二级标题
    ********

    三级标题
    ========

    四级标题
    --------

    五级标题
    ^^^^^^^^

    六级标题
    """"""""

实际上, 只有下方衬有字符与上下包裹字符都是一样的. 下面的说法是错误的:

.. error::

    以上是章节标题, 还有一种标题是 "文档标题", 对应 html 标签 ``<title>`` 或 ``<subtitle>``. 和章节标题类似, 文档标题只是用两行相同符号包裹文字. 这个貌似和主题有关, ``sphinx_rst_theme`` 把多余的标题解析成 ``<h7>`` ``<h8>`` 了.

    ::

        ======
        主标题
        ======

        ------
        副标题
        ------

段落
====

这一点 rst 几乎和 md 一样, 都是由空行划分的段落. 只不过, rst 中, 缩进也是控制段落的一个因素, 相同层级的段落, 缩进应当是一样的. 段落的缩进, 会影响渲染后文字的缩进.

这是一个 reStructureText 段落.

这是第二个 reStructureText 段落.

    这个段落被缩进了一下.

列表
====

和 Markdown 的列表标记差不多. 无序列表可以使用 ``*`` ``-`` 等符号, 有序列表则是枚举编号后跟一个点.

* 无序列表第一位
* 无序列表第二位
  也可以换行写, 只需要保持相同的缩进

  * 也可以嵌套, 但是需要空一行, 并且增加一级缩进.

0. 有序列表
1. 有序列表第二项
2. 编号乱跳是不行的, 只能按顺序来. (如果把前面的序号从 2 变成 3 或其他任何不是 2 的数字, 就会报错, 并且不会被解析为列表的下一项, 而是直接解在上一项的后面.)

#. 自动编号会接在同一缩进的有序列表下, 除非有其他段落隔断.

比如我这里就随便输了一个段落进行隔断.

#. 自动编号

另外, 列表前缀有多种形式可以使用, 例如 拉丁字母(a,b,c...) 罗马字母, 用括号代替点号等.

Field 列表
----------

应当用在代码的文档字符串中.

:param arg1: 第一个参数
:param arg2: 第二个参数
:returns: 返回值

::

    def function(arg1, arg2)
        """
        :param arg1: 第一个参数
        :param arg2: 第二个参数
        :returns: 返回值
        """

代码块
======

这下面是一个 C 语言的代码块. 只需要一个 ``::`` 符号, 在之后空一行, 并缩进一级后编辑代码. 当缩进结束时, 代表代码块结束. 可以指定代码高亮模式, 默认是 Python 代码的高亮模式.

::

    #include <stdio.h>
    int main()
    {
        printf("Hello\n");
        return 0;
    }

要指定高亮模式, 应使用 ``code-block`` 指令. code-block 可以指定其他属性, 例如 ``:linenos:`` 显示行号等.

.. code-block:: c
   :linenos:

    #include <stdio.h>
    int main()
    {
        printf("Hello\n");
        return 0;
    }

自定义代码高亮
--------------

Sphinx 是调用 pygments 进行语法高亮的.

超链接
======

参考式
------

参考式链接是在文本中使用链接文本, 将链接地址放在文档其他地方. **链接的地址需要指定协议, 否则会被当做相对路径.**

例如本文档参考了 `从 Markdown 到 reStructureText`_.

引用处, 下划线在后面, 参考处, 下划线在前面. 如果文本中含有空格, 可以使用反引号 ``\``` 将本文包括住.

如果一个链接对应多个文本, 可以这么表示::

    _文本表示1:
    _文本表示2:
    _文本表示最后: https://python.org

这样, ``文本表示1``, ``文本表示2``, ``文本表示最后`` 都对应一个链接.

内联式
------

内联式, 是将文本和链接写在一块. 相比参考式, 这更难以管理, 如果有多处引用了该链接, 需要多次输入链接. 但是, 对于那些临时使用的跳转链接, 这种方式还是很合适的.

用尖括号括住之后添加下划线, 或者直接书写链接. Sphinx 会自动将链接文本显示为 url::

    <https://python.org>_

或者使用反引号括住, 在前半部分书写显示文本 `Python 官网 <python.org>`_ ::

    `Python 官网 <https://python.org>`_

自动标题链接
------------

每一个标题, 都会自动生成一个锚点, 可以直接使用标题文本进行链接, 例如 `自动标题链接`_::

    `自动标题链接`_

替换语法
========

替换语法中的文本, 会在渲染时自动被定义好的语句替换.

|yufa|::

    |yufa|

    .. |yufa| replace:: 语法

.. |yufa| replace:: 语法

尾注
====

尾注 [#f1]_ 和链接用法类似. 源代码中尾注内容可以放在任何位置, 但是引用尾注处必须使用空格与其他文本分开.

使用 ``[#]`` 自动编号. 或者使用 ``[#name]`` 为特定尾注命名::

    尾注 [#fn]_

    .. [#fn] 或者叫脚注, footnote.

尾注 [#fn]_

.. [#fn] 或者叫脚注, footnote.

引用图片
========

Sphinx 使用指令来作为 reStructureText 的扩展. 指令的一大作用, 就是快速添加文档结构, 而无需对底层代码进行修改.

使用 ``image`` 指令. 开头两个点, 空一格, 输入 ``image``, 然后连用两个冒号 ``::`` 再空一格, 输入到图片的路径, 可以使用相对路径或绝对路径, 相对路径是相对于文档文件的. 可以在下面添加属性, 所有属性和 HTML 中的图片属性是一样的.

.. image:: img/59498721_p0.jpg
   :alt: 示例图片

::

    .. image:: img/59498721_p0.jpg
    :alt: 示例图片

表格
====

在 VsCode 上编辑表格, 最好下载一个 `Table Formatter <https://marketplace.visualstudio.com/items?itemName=shuworks.vscode-table-formatter>`_ 否则就会被打格式符烦死.

普通表格
--------

== == ===
A  B  A&B
== == ===
否 否 否
是 否 否
否 是 否
是 是 是
== == ===

::

    == == ===
    A  B  A&B
    == == ===
    否 否 否
    是 否 否
    否 是 否
    是 是 是
    == == ===

网格表格
--------

+------------+----------+
| 网格1      | 网格2    |
+------------+----------+
| 无等宽字体 | 就特别烦 |
+------------+----------+

::

    +------------+----------+
    | 网格1      | 网格2    |
    +------------+----------+
    | 无等宽字体 | 就特别烦 |
    +------------+----------+

选项列表
--------

选项列表看起来就是为了方便命令行参数帮助的展示而定义的样式.

--sourcedir         path to documentation source files
--outputdir         path to output directory
--filenames         a list of specific files to rebuild. Ignored if -a is
                    specified

内联样式
========

*斜体* **粗体** ``代码``

::

    *斜体* **粗体** ``代码``

水平线
======

至少四个 ``-`` 将会被解析为水平线. (``<hr />`` 标签)

----

测试文档
========

>>> print('this is a Doctest block')
this is a Doctest block

测试文档是一个以 Python 的提示符 ``>>>`` 开头的段落, 应该用在代码的注释中, 配合 ``sphinx.ext.doctest`` 使用.

.. _`Docutils 中文文档`: https://docutils-zh-cn.readthedocs.io/zh_CN/latest/
.. _`从 Markdown 到 reStructureText`: https://macplay.github.io/posts/cong-markdown-dao-restructuredtext/#id21
.. [#f1] 尾注的文本最好放在源代码末端, 便于管理

.. |reST| replace:: reStructuredText
