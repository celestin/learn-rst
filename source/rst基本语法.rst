############
rst 基本语法
############

.. highlight:: text

Sphinx 默认使用 |reST| 标记语言(通常简称为 rst 或 reST), 要能够处理 Markdown 还需要额外的渲染器, 而且在了解一番过后, 发现 |reST| 支持的内容比 Markdown 更丰富, 于是决定学习一下. 建议克隆该库, 自己使用 ``make html`` 编译结果, 再对照源码学习 reStructureText 的语法.

|reST| 和 Python 一样, 很多表达都依赖缩进. (所以你的编辑器上最好有📏2333)

以下内容翻译自 `A ReStructuredText Primer <http://docutils.sourceforge.net/docs/user/rst/quickstart.html>`_:

:Author: Richard Jones
:Version: 5801
:Copyright: This document has been placed in the public domain.

结构
====

首先, 让我说 "结构化文本" 可能有些用词不当. |reST| 更像使用某些一致模式的 "轻松文本". 这些模式被 HTML 转换器解释产生 "非常结构化" 的文本, 该文本才可被 Web 浏览器使用.

最基本的被识别的模式是 `段落`. 这是一个被空行分隔的文本区块(一行就够了). 段落必须由相同的索引 -- 也就是说, 在它们的左边缘需要对齐. 开始缩进的段落将产生对应缩进的引用段落. 例如::

    这是一个段落. 它有点
    短.

        这个段落将会产生一个缩进块的文本, 通常用作表示引用其他文本.

    这是另一段.

结果:

这是一个段落. 它有点
短.

    这个段落将会产生一个缩进块的文本, 通常用作表示引用其他文本.

这是另一段.

文本样式
========

在段落和其他文本体内, 你可以使用额外的文本记号用 "\*斜体\*" 作 *斜体*
或者 "\*\*粗体\*\*" 作 **粗体**. 这被称作 "行内标记".

如果你想要一些显示为固定空间的纯文本, 使用 "\`\`双反引号\`\`". 注意
不要在双反引号里加任何别的标记 -- 例如星号 "\*".

如果你发现你想要使用单个独特的文本字符, 这通常也是可以的 -- |reST|
非常聪明. 例如, 单独的 * 星号被处理得很好, 像这个算式里的星号: 5*6=30.
如果你实际想要让 \*被星号包围的文本\* **不要** 被斜体化, 你需要表明
星号不是特殊的. 你通过放置反斜杠在它前面, 例如 "\\\*", 或者用闭合的
双反引号像这样::

    ``*``

.. tip::

    将内联标记想象成括号的一种形式, 并用相同的方式使用它: 在标记文本
    的前后. 由空格包围或单词中间的内联标记本身不会被识别, 有关详细信息, 参考标记规范.

列表
====

有三种风格来表示一列项目, 枚举、项目符号和定义. 在所有列表用例中,
你可能有许多段落、子列表等等. 如你所欲, 只要段落或不管什么东西在
左手边的缩进对齐了列表项目的第一行文本即可.

列表必须在一个新的段落开始 -- 也就是必须出现在空行之后.

枚举列表
    数字, 字母或罗马数字

    以一个跟着点 ``.`` 或右括号 ``)`` 或 被括号包围 ``()`` 的数字或字母开始的行 -- 无论你偏好什么. 所有这些格式都能识别::

        1. 数字

        A.  大写字母
            并且跨行

            甚至两段!

        a. 小写字母

            3. 跟着一个以不同数字开始的子列表
            4. 保证数字顺序正确!

        I. 大写罗马数字

        i. 小写罗马数字

        (1) 又是数字

        1) 再放送

    结果:

    1. 数字

    A.  大写字母
        并且跨行

        甚至两段!

    a. 小写字母

        3. 跟着一个以不同数字开始的子列表
        4. 保证数字顺序正确!

    I. 大写罗马数字

    i. 小写罗马数字

    (1) 又是数字

    1) 再放送

项目符号列表
    就像枚举列表一样, 以一个项目点符号开始, "-", "+" 或 "*", 选其中之一::

        *   一个使用 "*" 的项目符号点

            -   一个使用 "-" 的子列表

                +   另一个子列表

            -   另一个项目

    结果:

    *   一个使用 "*" 的项目符号点

        -   一个使用 "-" 的子列表

            +   另一个子列表

        -   另一个项目

定义列表
    不像另两种, 定义列表由一个术语和这个术语的定义组成. 定义列表的格式为::

        什么
            定义列表将定义和术语相关联.

        *怎么*
            术语是一个单行的短语, 定义是一个或多个段落或体元素, 相对
            术语有一个缩进. 在术语和定义间不允许空行.

    结果:

    什么
        定义列表将定义和术语相关联.

    *怎么*
        术语是一个单行的短语, 定义是一个或多个段落或体元素, 相对
        术语有一个缩进. 在术语和定义间不允许空行.

预格式化 (代码样例)
===================

只想包含一个预格式化区块, 绝不被摆弄的文本, 让之前的段落以 ``::``
结束. 当文本退回到与预格式化块之前的段落相同的缩进级别时,
预格式化块结束. 例如::

    一个例子::

        空白, 新行, 空行, 和其他各种类型的标记
            (例如 *this* 或 \this) 被纯文本块良好的保留了下来.
      看这, 我丢下了一些缩进级别
      (但不足够)

    没更多例子了.

结果:

一个例子::

    空白, 新行, 空行, 和其他各种类型的标记
        (例如 *this* 或 \this) 被纯文本块良好的保留了下来.
  看这, 我丢下了一些缩进级别
  (但不足够)

没更多例子了.

注意, 如果一个段落只由 ``::`` 组成, 那么它在输出中将被去除::

    ::

        这是一个预格式化文本, 并且
        最后一个 "::" 段落被移除

结果:

::

    这是一个预格式化文本, 并且
    最后一个 "::" 段落被移除

章节
====

将长文本划分为不同的章节, 你需要章节标题. 这是一些带装饰的单行文本
(一个或更多词语): 一个下划线, 或者一对下划线和上划线, 用破折号
"-----", 等号 "======", 波浪线 "~~~~~~" 或者其他你喜欢的
非字母数字的字符 ``=0`:'"~^_*+#<>``. 一个只下划的装饰不同于一个
使用相同字符的上下划的状石. 装饰必须至少有标题文本一样数目的字符.
保持一致, 因为所有标有相同装饰风格的部分都被视作同一级别::

    第 1 章 标题
    ============

    第 1.1 节 标题
    --------------

    第 1.1.1 子节 标题
    ~~~~~~~~~~~~~~~~~~

    第 1.2 节 标题
    --------------

    第 2 章 标题
    ============

这将产生以下结构, 用简化的伪 XML 来说明::

    <section title="第 1 章 标题">
        <section title="第 1.1 节 标题">
            <section title="第 1.1.1 子节 标题">
        <section title="第 1.2 节 标题>
    <section title="第 2 章 标题">

注意这些标题可以作为链接的目标, 只需要使用它们的名字.
为了链接到 列表_, 我写下 "``Lists_``".
如果你要链接到拥有空格的标题例如 `预格式化 (代码样例)`_,
你需要使用反引号 ```预格式化 (代码样例)`_``.

.. warning:: 译者注

    一个中文字符相当于两个字母的宽度

.. |reST| replace:: reStructuredText
